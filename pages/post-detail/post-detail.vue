<template>
    <view>
        
        <!-- pages/post-detail/post-detail.wxml -->
        <view class="container">
            <block v-if="isLoading">
                <view class="loading-container">
                    <view class="loading-text">Âä†ËΩΩ‰∏≠...</view>
                </view>
            </block>
            <block v-else-if="post && post._id">
                <!-- Post Card -->
                <view :class="'post-detail-card ' + (post.isOriginal ? 'original-post' : '')">
                    <view class="author-info">
                        <view class="author-basic">
                            <image
                                v-if="post.authorAvatar"
                                class="author-avatar"
                                :src="post.authorAvatar"
                                mode="aspectFill"
                                @error="onAvatarError"
                                @tap="navigateToUserProfile"
                                :data-user-id="post._openid"
                            ></image>
                            <text class="author-name">{{ post.authorName }}</text>
                            <view v-if="isMutualFollow" class="mutual-tag">‰∫íÁõ∏ÂÖ≥Ê≥®</view>
                            <view v-else-if="isFollowedByAuthor" class="followed-tag">TAÂÖ≥Ê≥®‰∫Ü‰Ω†</view>
                        </view>
                        <button
                            v-if="showFollowButton"
                            :class="'follow-btn ' + (isFollowing ? 'following' : '')"
                            @tap="onFollowTap"
                            :loading="followPending"
                            :disabled="followPending"
                        >
                            {{ isFollowing ? 'Â∑≤ÂÖ≥Ê≥®' : 'ÂÖ≥Ê≥®' }}
                        </button>
                    </view>
                    <view class="post-title">{{ post.title }}</view>
                    <view v-if="post.isPoem && post.author" class="poem-author">{{ post.author }}</view>
                    <view class="post-content" v-if="post.content">{{ post.content }}</view>

                    <view v-if="post.tags && post.tags.length > 0" class="post-tags">
                        <text class="post-tag" @tap.stop.prevent="onTagClick" :data-tag="item" v-for="(item, index) in post.tags" :key="index">#{{ item }}</text>
                    </view>

                    <view v-if="post.imageUrl || (post.imageUrls && post.imageUrls.length > 0)" class="image-container" id="detail-image-container">
                        <block v-if="post.imageUrls && post.imageUrls.length === 1">
                            <image
                                :id="'single-image-' + (post && post._id ? post._id : '')"
                                :src="post.imageUrls[0]"
                                :mode="(post && post._id && imageClampHeights[post._id]) ? 'aspectFill' : 'widthFix'"
                                :style="
                                    'width: 100%; height: ' +
                                    (post && post._id && imageClampHeights[post._id] ? imageClampHeights[post._id] + 'px' : 'auto') +
                                    '; object-fit: ' +
                                    (post && post._id && imageClampHeights[post._id] ? 'cover' : 'contain') +
                                    '; background-color: #f0f0f0;'
                                "
                                @load="onImageLoad"
                                :data-postid="post && post._id ? post._id : ''"
                                data-type="single"
                                @error="onImageError"
                                @tap.stop.prevent="handlePreview"
                                :data-src="post.imageUrls[0]"
                                :data-original-image-urls="post.originalImageUrls || post.imageUrls"
                                :lazy-load="true"
                            />
                        </block>

                        <block v-else-if="post.imageUrls && post.imageUrls.length > 1">
                            <swiper
                                :id="'swiper-' + (post && post._id ? post._id : '')"
                                class="image-swiper"
                                :indicator-dots="true"
                                :circular="true"
                                :style="'width: 100%; height: ' + (swiperHeights[0] ? swiperHeights[0] + 'px' : '220px') + ';'"
                            >
                                <block v-for="(img, imgindex) in post.imageUrls" :key="imgindex">
                                    <swiper-item>
                                        <image
                                            :src="img"
                                            mode="aspectFill"
                                            @load="onImageLoad"
                                            :data-postid="post && post._id ? post._id : ''"
                                            data-postindex="0"
                                            :data-imgindex="imgindex"
                                            data-type="multi"
                                            @error="onImageError"
                                            @tap.stop.prevent="handlePreview"
                                            :data-src="img"
                                            :data-original-image-urls="post.originalImageUrls || post.imageUrls"
                                            :lazy-load="true"
                                            style="width: 100%; height: 100%; object-fit: cover; background-color: #f0f0f0"
                                        />
                                    </swiper-item>
                                </block>
                            </swiper>
                        </block>
                    </view>

                    <view class="post-meta">
                        <text class="post-time">{{ post.formattedCreateTime }}</text>
                    </view>
                    <view class="vote-section" @tap.stop.prevent="preventBubble">
                        <view class="actions-left">
                            <button :class="favoriteButtonClass" size="mini" @tap.stop.prevent="onFavorite">
                                {{ favoriteButtonText }}
                            </button>
                        </view>
                        <view class="button-group">
                            <view class="comment-count">
                                <text class="action-emoji">üí¨</text>
                                <text class="action-text">{{ commentCount }}</text>
                            </view>
                            <view class="like-icon-container" @tap.stop.prevent="onVote" :data-postid="post && post._id ? post._id : ''">
                                <image class="like-icon" :src="post.likeIcon" mode="aspectFit"></image>
                            </view>
                            <view :class="'vote-count ' + (post.isVoted ? 'voted' : '')">
                                <text class="action-text">{{ post.votes || 0 }}</text>
                            </view>
                        </view>
                    </view>
                </view>

                <!-- Comment Section -->
                <view class="comment-section">
                    <view class="section-title">ÂÖ±{{ commentCount }} Êù°ËØÑËÆ∫</view>
                    <view class="comment-list">
                        <block v-if="comments.length > 0">
                            <view class="comment-item" v-for="(item, commentIndex) in comments" :key="commentIndex">
                                <image
                                    class="comment-avatar"
                                    :src="item.authorAvatar"
                                    mode="aspectFill"
                                    @error="onAvatarError"
                                    @tap="navigateToUserProfile"
                                    :data-user-id="item._openid"
                                ></image>

                                <view class="comment-main">
                                    <view class="comment-author">{{ item.authorName }}</view>
                                    <view class="comment-content">{{ item.content }}</view>
                                    <view v-if="item.imageUrls && item.imageUrls.length" class="comment-image-grid">
                                        <image
                                            class="comment-image"
                                            :src="commentImage"
                                            mode="aspectFill"
                                            @tap="previewCommentImageFromList"
                                            :data-comment-index="commentIndex"
                                            :data-image-index="imageIndex"
                                            :data-is-reply="false"
                                            v-for="(commentImage, imageIndex) in item.imageUrls"
                                            :key="imageIndex"
                                        ></image>
                                    </view>
                                    <view class="comment-footer">
                                        <view class="comment-time">{{ item.formattedCreateTime }}</view>
                                        <view class="comment-actions">
                                            <view class="like-section" @tap="toggleLikeComment" :data-comment-id="item._id" :data-liked="item.liked">
                                                <image class="like-icon" :src="item.likeIcon"></image>
                                                <text class="like-count">{{ item.likes || 0 }}</text>
                                            </view>
                                            <view v-if="item.canDelete" class="delete-btn" @tap="onDeleteComment" :data-comment-id="item._id">
                                                <text class="delete-text">Âà†Èô§</text>
                                            </view>
                                            <view class="reply-btn" @tap="showReplyInput" :data-comment-id="item._id" :data-author-name="item.authorName">
                                                <text class="reply-text">ÂõûÂ§ç</text>
                                            </view>
                                        </view>
                                    </view>

                                    <!-- Replies -->
                                    <view v-if="item.replies && item.replies.length > 0" class="replies-container">
                                        <view
                                            class="reply-item"
                                            v-if="replyIndex < (item.showAllReplies ? item.replies.length : 3)"
                                            v-for="(reply, replyIndex) in item.replies"
                                            :key="replyIndex"
                                        >
                                            <image
                                                class="reply-avatar"
                                                :src="reply.authorAvatar"
                                                mode="aspectFill"
                                                @error="onAvatarError"
                                                @tap="navigateToUserProfile"
                                                :data-user-id="reply._openid"
                                            ></image>

                                            <view class="reply-main">
                                                <view class="reply-author">{{ reply.authorName }}</view>
                                                <view class="reply-content">
                                                    <text class="reply-to">ÂõûÂ§ç@{{ item.authorName }}Ôºö</text>
                                                    <text>{{ reply.content }}</text>
                                                </view>
                                                <view v-if="reply.imageUrls && reply.imageUrls.length" class="comment-image-grid reply-image-grid">
                                                    <image
                                                        class="comment-image"
                                                        :src="replyImage"
                                                        mode="aspectFill"
                                                        @tap="previewCommentImageFromList"
                                                        :data-comment-index="commentIndex"
                                                        :data-reply-index="replyIndex"
                                                        :data-image-index="replyImageIndex"
                                                        :data-is-reply="true"
                                                        v-for="(replyImage, replyImageIndex) in reply.imageUrls"
                                                        :key="replyImageIndex"
                                                    ></image>
                                                </view>
                                                <view class="reply-footer">
                                                    <view class="reply-time">{{ reply.formattedCreateTime }}</view>
                                                    <view class="reply-actions">
                                                        <view class="like-section" @tap="toggleLikeComment" :data-comment-id="reply._id" :data-liked="reply.liked">
                                                            <image class="like-icon" :src="reply.likeIcon"></image>
                                                            <text class="like-count">{{ reply.likes || 0 }}</text>
                                                        </view>
                                                        <view
                                                            v-if="reply.canDelete"
                                                            class="delete-btn"
                                                            @tap="onDeleteComment"
                                                            :data-comment-id="reply._id"
                                                            :data-parent-id="item._id"
                                                        >
                                                            <text class="delete-text">Âà†Èô§</text>
                                                        </view>
                                                        <view class="reply-btn" @tap="showReplyInput" :data-comment-id="item._id" :data-author-name="reply.authorName">
                                                            <text class="reply-text">ÂõûÂ§ç</text>
                                                        </view>
                                                    </view>
                                                </view>
                                            </view>
                                        </view>

                                        <view
                                            v-if="item.replies.length > 3 && !item.showAllReplies"
                                            class="show-more-replies"
                                            @tap="toggleShowAllReplies"
                                            :data-comment-id="item._id"
                                        >
                                            <text class="show-more-text">ÊòæÁ§∫{{ item.replies.length - 3 }}Êù°ÂõûÂ§ç</text>
                                        </view>

                                        <view
                                            v-if="item.replies.length > 3 && item.showAllReplies"
                                            class="show-more-replies"
                                            @tap="toggleShowAllReplies"
                                            :data-comment-id="item._id"
                                        >
                                            <text class="show-more-text">Êî∂Ëµ∑ÂõûÂ§ç</text>
                                        </view>
                                    </view>
                                </view>
                            </view>
                        </block>
                        <block v-else>
                            <view class="no-comment-tip">
                                <view class="empty-icon">üí¨</view>
                                <view class="empty-text">ÊöÇÊó†ËØÑËÆ∫ÔºåÂø´Êù•Êä¢Ê≤ôÂèëÂêßÔºÅ</view>
                            </view>
                        </block>
                    </view>
                </view>
            </block>
            <block v-else>
                <view class="error-container">
                    <view class="error-icon">‚ùå</view>
                    <view class="error-text">Â∏ñÂ≠êÂä†ËΩΩÂ§±Ë¥•Êàñ‰∏çÂ≠òÂú®</view>
                </view>
            </block>
        </view>

        <!-- ÈÅÆÁΩ©Â±ÇÔºöÂΩìËæìÂÖ•Ê°ÜÂ±ïÂºÄÊó∂ÊòæÁ§∫ -->
        <view :class="'input-overlay ' + (isInputExpanded ? 'show' : '')" @tap="collapseInput"></view>

        <!-- ËæìÂÖ•Ê°ÜÂÆπÂô®ÔºöÊï¥‰Ωì‰ºöÊ†πÊçÆÈîÆÁõòÈ´òÂ∫¶‰∏äÁßª -->
        <view class="comment-input-area" :style="'bottom: ' + keyboardHeight + 'px;'">
            <!-- Êî∂Ëµ∑Áä∂ÊÄÅÔºö‰∏Ä‰∏™ÂÅáÁöÑËæìÂÖ•Ê°ÜÔºåÁÇπÂáªÂêéÂ±ïÂºÄ -->
            <view v-if="!isInputExpanded" class="collapsed-bar" @tap="expandInput">
                <view class="collapsed-input-placeholder">Áïô‰∏ã‰Ω†ÁöÑÁ≤æÂΩ©ËØÑËÆ∫...</view>
            </view>

            <!-- Â±ïÂºÄÁä∂ÊÄÅÔºöÁúüÊ≠£ÁöÑËæìÂÖ•Âå∫Âüü -->
            <view v-if="isInputExpanded" class="expanded-container">
                <!-- Â¶ÇÊûúÊòØÂõûÂ§çÔºåÊòæÁ§∫ÊèêÁ§∫ -->
                <view v-if="replyToComment" class="reply-prompt">
                    <text class="reply-prompt-text">ÂõûÂ§ç {{ replyToAuthor }}Ôºö</text>
                    <view class="cancel-reply" @tap="cancelReply">
                        <text class="cancel-text">ÂèñÊ∂à</text>
                    </view>
                </view>

                <!-- Â§öË°åÊñáÊú¨ËæìÂÖ•Ê°Ü -->
                <textarea
                    class="expanded-textarea"
                    placeholder="Áïô‰∏ã‰Ω†ÁöÑÁ≤æÂΩ©ËØÑËÆ∫..."
                    :value="newComment"
                    @input="onCommentInput"
                    @focus="onInputFocus"
                    @blur="onInputBlur"
                    :focus="isFocus"
                    auto-height
                    maxlength="500"
                    :show-confirm-bar="false"
                    :adjust-position="false"
                ></textarea>
                <view v-if="commentImages.length" class="selected-comment-images">
                    <view class="selected-image-item" :data-index="index" v-for="(item, index) in commentImages" :key="index">
                        <image class="selected-image-thumb" :src="item.previewUrl" mode="aspectFill" @tap="previewSelectedCommentImage" :data-index="index"></image>

                        <view class="remove-image-btn" @tap="removeCommentImage" :data-index="index">‚úï</view>
                    </view>
                </view>

                <!-- Â∫ïÈÉ®Êìç‰ΩúÊ†èÔºåÂåÖÂê´ÂèëÈÄÅÊåâÈíÆ -->
                <view class="expanded-actions">
                    <view class="action-icons">
                        <view class="action-icon" @tap="chooseCommentImages">
                            <text class="action-icon-text">üñºÔ∏è</text>
                        </view>
                        <view class="action-icon" @tap="toggleEmojiPanel">
                            <text class="action-icon-text">üòä</text>
                        </view>
                    </view>
                    <button class="submit-button" @tap="onSubmitComment" :disabled="isSubmitDisabled">ÂèëÈÄÅ</button>
                </view>
                <view v-if="showEmojiPanel" class="emoji-panel">
                    <text class="emoji-item" :data-emoji="item" @tap="insertEmoji" v-for="(item, index) in emojiList" :key="index">{{ item }}</text>
                </view>
            </view>
        </view>

        <!-- Cloud Tip Modal -->
        <cloud-tip-modal :showUploadTip="showUploadTip"></cloud-tip-modal>

        <!-- Êî∂ËóèÂ§πÈÄâÊã©Âô® -->
        <folder-selector :show="showFavoriteModal" :post-id="post && post._id ? post._id : ''" @hide="hideFavoriteModal" @favoriteSuccess="onFavoriteSuccess" />
    </view>
</template>

<script>
import cloudTipModal from '@/components/cloudTipModal/index';
import folderSelector from '@/components/folder-selector/folder-selector';
// pages/post-detail/post-detail.js
const app = getApp();
const likeIcon = require('../../utils/likeIcon');
const avatarCache = require('../../utils/avatarCache');
const followCache = require('../../utils/followCache');
const dataCache = require('../../utils/dataCache');
export default {
    components: {
        cloudTipModal,
        folderSelector
    },
    data() {
        return {
            post: null,
            comments: [],
            newComment: '',
            commentCount: 0,
            isLoading: true,
            isSubmitDisabled: true,
            replyToComment: null,
            replyToAuthor: '',
            showUploadTip: false,
            votingInProgress: false,
            imageContainerHeight: null,
            swiperHeights: {},
            imageClampHeights: {},
            showFavoriteModal: false,
            isInputExpanded: false,
            keyboardHeight: 0,
            isFocus: false,
            viewStartTime: 0,
            currentPostId: null,
            isFavorited: false,
            favoriteButtonText: 'Êî∂Ëóè',
            favoriteButtonClass: 'favorite-button',
            showFollowButton: false,
            isFollowing: false,
            followPending: false,
            isFollowedByAuthor: false,
            isMutualFollow: false,
            commentImages: [],
            maxCommentImages: 3,
            showEmojiPanel: false,
            emojiList: ['üòÄ', 'üòÅ', 'üòÇ', 'ü§£', 'üòä', 'üòç', 'üòé', 'ü§î', 'üò¢', 'üôè', 'üëç', 'üëé'],
            isSubmittingComment: false,
            imgindex: 0,
            img: '',
            commentIndex: 0,
            commentImage: '',
            imageIndex: 0,
            replyIndex: 0,

            reply: {
                authorAvatar: '',
                _openid: '',
                authorName: '',
                content: '',
                imageUrls: '',
                formattedCreateTime: '',
                _id: '',
                liked: '',
                likeIcon: '',
                likes: '',
                canDelete: ''
            },

            replyImage: '',
            replyImageIndex: 0
        };
    },
    onLoad: function (options) {
        const postId = options.id;
        if (postId) {
            this.setData({
                currentPostId: postId
            });
            this.loadPostDetail(postId);
        } else {
            this.setData({
                isLoading: false
            });
            uni.showToast({
                title: 'Êó†ÊïàÁöÑÂ∏ñÂ≠êID',
                icon: 'none'
            });
        }
    },
    onShow: function () {
        this.setData({
            viewStartTime: Date.now()
        });
    },
    onUnload: function () {
        this.recordViewBehavior();
    },
    onHide: function () {
        if (this.isInputExpanded) {
            this.collapseInput();
        }
        this.recordViewBehavior();
    },
    methods: {
        // ÂÖºÂÆπÊÄß‰∫ëÂáΩÊï∞Ë∞ÉÁî®ÊñπÊ≥ï
        callCloudFunction(name, data = {}) {
            console.log(`üîç [PostDetailÈ°µÈù¢] Ë∞ÉÁî®‰∫ëÂáΩÊï∞: ${name}`, data);
            
            return new Promise((resolve, reject) => {
                // ‰ΩøÁî®Êñ∞ÁöÑÂπ≥Âè∞Ê£ÄÊµãÂ∑•ÂÖ∑
                const { getCurrentPlatform, getCloudFunctionMethod, logPlatformInfo } = require('../../utils/platformDetector.js');
                const { debugEnvironmentDetection, testCloudFunctionCapability } = require('../../utils/debugPlatform.js');
                
                // ËØ¶ÁªÜÁöÑÁéØÂ¢ÉÊ£ÄÊµãË∞ÉËØï
                debugEnvironmentDetection();
                
                const platform = getCurrentPlatform();
                const method = getCloudFunctionMethod();
                const capability = testCloudFunctionCapability();
                
                console.log(`üîç [PostDetailÈ°µÈù¢] ËøêË°åÁéØÂ¢É: ${platform}, Ë∞ÉÁî®ÊñπÂºè: ${method}, ÂÆûÈôÖËÉΩÂäõ: ${capability}`);
                
                // ÊâìÂç∞ËØ¶ÁªÜÁöÑÂπ≥Âè∞‰ø°ÊÅØÔºàË∞ÉËØïÁî®Ôºâ
                logPlatformInfo();
                
                // Â¶ÇÊûúÊ£ÄÊµãÂà∞ÁöÑË∞ÉÁî®ÊñπÂºè‰∏éÂÆûÈôÖËÉΩÂäõ‰∏çÂåπÈÖçÔºå‰ΩøÁî®ÂÆûÈôÖËÉΩÂäõ
                const actualMethod = capability !== 'none' ? capability : method;
                console.log(`üîç [PostDetailÈ°µÈù¢] ÊúÄÁªà‰ΩøÁî®Ë∞ÉÁî®ÊñπÂºè: ${actualMethod}`);
                
                if (actualMethod === 'tcb') {
                    // ‰ΩøÁî®TCBË∞ÉÁî®‰∫ëÂáΩÊï∞ÔºàH5ÂíåAppÁéØÂ¢ÉÔºâ
                    if (this.$tcb && this.$tcb.callFunction) {
                        console.log(`üîç [PostDetailÈ°µÈù¢] ‰ΩøÁî®TCBË∞ÉÁî®‰∫ëÂáΩÊï∞: ${name} (ÁéØÂ¢É: ${platform})`);
                        this.$tcb.callFunction({
                            name: name,
                            data: data
                        }).then(resolve).catch(reject);
                    } else {
                        console.error(`‚ùå [PostDetailÈ°µÈù¢] ${platform}ÁéØÂ¢ÉTCB‰∏çÂèØÁî®`);
                        console.error(`‚ùå [PostDetailÈ°µÈù¢] this.$tcb:`, this.$tcb);
                        console.error(`‚ùå [PostDetailÈ°µÈù¢] this.$tcb.callFunction:`, typeof (this.$tcb && this.$tcb.callFunction));
                        reject(new Error('TCBÂÆû‰æã‰∏çÂèØÁî®'));
                    }
                } else if (actualMethod === 'wx-cloud') {
                    // ‰ΩøÁî®ÂæÆ‰ø°‰∫ëÂºÄÂèëË∞ÉÁî®‰∫ëÂáΩÊï∞ÔºàÂ∞èÁ®ãÂ∫èÁéØÂ¢ÉÔºâ
                    if (wx.cloud && wx.cloud.callFunction) {
                        console.log(`üîç [PostDetailÈ°µÈù¢] ‰ΩøÁî®ÂæÆ‰ø°‰∫ëÂºÄÂèëË∞ÉÁî®‰∫ëÂáΩÊï∞: ${name}`);
                        wx.cloud.callFunction({
                            name: name,
                            data: data,
                            success: (res) => {
                                console.log(`‚úÖ [PostDetailÈ°µÈù¢] ‰∫ëÂáΩÊï∞Ë∞ÉÁî®ÊàêÂäü: ${name}`, res);
                                resolve(res);
                            },
                            fail: (err) => {
                                console.error(`‚ùå [PostDetailÈ°µÈù¢] ‰∫ëÂáΩÊï∞Ë∞ÉÁî®Â§±Ë¥•: ${name}`, err);
                                reject(err);
                            }
                        });
                    } else {
                        console.error(`‚ùå [PostDetailÈ°µÈù¢] Â∞èÁ®ãÂ∫èÁéØÂ¢ÉÂæÆ‰ø°‰∫ëÂºÄÂèë‰∏çÂèØÁî®`);
                        console.error(`‚ùå [PostDetailÈ°µÈù¢] wx.cloud:`, typeof wx.cloud);
                        console.error(`‚ùå [PostDetailÈ°µÈù¢] wx.cloud.callFunction:`, typeof (wx.cloud && wx.cloud.callFunction));
                        reject(new Error('ÂæÆ‰ø°‰∫ëÂºÄÂèë‰∏çÂèØÁî®'));
                    }
                } else {
                    console.error(`‚ùå [PostDetailÈ°µÈù¢] ‰∏çÊîØÊåÅÁöÑ‰∫ëÂáΩÊï∞Ë∞ÉÁî®ÊñπÂºè: ${actualMethod}`);
                    reject(new Error(`‰∏çÊîØÊåÅÁöÑ‰∫ëÂáΩÊï∞Ë∞ÉÁî®ÊñπÂºè: ${actualMethod}`));
                }
            });
        },
        loadPostDetail: function (postId) {
            uni.showLoading({
                title: 'Âä†ËΩΩ‰∏≠...'
            });
            this.$tcb.callFunction({
                name: 'getPostDetail',
                data: {
                    postId: postId
                }
            }).then((res) => {
                if (res.result && res.result.post) {
                    let post = res.result.post;
                    post.formattedCreateTime = this.formatTime(post.createTime);
                    post.likeIcon = likeIcon.getLikeIcon(post.votes || 0, post.isVoted || false);
                    console.log('loadPostDetailÂÆåÊï¥ËøîÂõûÊï∞ÊçÆ:', res.result);
                    console.log('loadPostDetailËé∑ÂèñÂà∞ÁöÑcommentCount:', res.result.commentCount, 'Á±ªÂûã:', typeof res.result.commentCount);
                    console.log('loadPostDetailËé∑ÂèñÂà∞ÁöÑpost.commentCount:', post.commentCount, 'Á±ªÂûã:', typeof post.commentCount);
                    const finalCommentCount = res.result.commentCount || post.commentCount || 0;
                    console.log('ÊúÄÁªà‰ΩøÁî®ÁöÑcommentCount:', finalCommentCount);
                    this.setData({
                        post: post,
                        commentCount: finalCommentCount
                    });
                    console.log('loadPostDetailËÆæÁΩÆÂêéÁöÑcommentCount:', this.commentCount);
                    this.getComments(post && post._id ? post._id : '');
                    this.prepareFollowState(post._openid);
                } else {
                    uni.showToast({
                        title: 'Â∏ñÂ≠êÂä†ËΩΩÂ§±Ë¥•',
                        icon: 'none'
                    });
                }
            }).catch((err) => {
                console.error('Failed to get post detail', err);
                uni.showToast({
                    title: 'ÁΩëÁªúÈîôËØØ',
                    icon: 'none'
                });
            }).finally(() => {
                this.setData({
                    isLoading: false
                });
                uni.hideLoading();
            });
        },

        getComments: function (postId) {
            this.$tcb.callFunction({
                name: 'getComments',
                data: {
                    postId: postId
                }
            }).then((res) => {
                if (res.result && res.result.comments) {
                    const currentUserOpenid = this.openid || uni.getStorageSync('openid');
                    const comments = res.result.comments.map((comment) => {
                        const processedComment = {
                            ...comment,
                            formattedCreateTime: this.formatTime(comment.createTime),
                            likeIcon: likeIcon.getLikeIcon(comment.likes || 0, comment.liked || false),
                            canDelete: comment._openid === currentUserOpenid,
                            imageUrls: comment.imageUrls || [],
                            originalImageUrls: comment.originalImageUrls || []
                        };
                        if (comment.replies) {
                            processedComment.replies = comment.replies.map((reply) => ({
                                ...reply,
                                formattedCreateTime: this.formatTime(reply.createTime),
                                likeIcon: likeIcon.getLikeIcon(reply.likes || 0, reply.liked || false),
                                canDelete: reply._openid === currentUserOpenid,
                                imageUrls: reply.imageUrls || [],
                                originalImageUrls: reply.originalImageUrls || []
                            }));
                        }
                        return processedComment;
                    });
                    console.log('getCommentsËøîÂõûÁöÑcommentCount:', res.result.commentCount);
                    console.log('commentsÊï∞ÁªÑÈïøÂ∫¶:', comments.length);
                    console.log('ÂΩìÂâçÈ°µÈù¢ÁöÑcommentCount:', this.commentCount);
                    const newCommentCount = res.result.commentCount || comments.length;
                    const shouldUpdateCount = newCommentCount > this.commentCount;
                    this.setData({
                        comments: comments,
                        commentCount: shouldUpdateCount ? newCommentCount : this.commentCount
                    });
                    console.log('Êõ¥Êñ∞ÂêéÁöÑcommentCount:', this.commentCount);
                } else {
                    uni.showToast({
                        title: 'ËØÑËÆ∫Âä†ËΩΩÂ§±Ë¥•',
                        icon: 'none'
                    });
                }
            }).catch((err) => {
                console.error('Failed to get comments', err);
                uni.showToast({
                    title: 'ÁΩëÁªúÈîôËØØ',
                    icon: 'none'
                });
            });
        },

        onVote: function (event) {
            const postId = event.currentTarget.dataset.postid;
            if (this.votingInProgress) {
                return;
            }
            this.setData({
                votingInProgress: true
            });
            const post = this.post;
            const originalVotes = post.votes;
            const originalIsVoted = post.isVoted;
            const newVotes = originalIsVoted ? originalVotes - 1 : originalVotes + 1;
            const newIsVoted = !originalIsVoted;
            const newLikeIcon = likeIcon.getLikeIcon(newVotes, newIsVoted);
            this.setData({
                'post.votes': newVotes,
                'post.isVoted': newIsVoted,
                'post.likeIcon': newLikeIcon
            });
            this.callCloudFunction('vote', {
                    postId: postId
                }).then((res) => {
                    if (!res.result.success) {
                        this.setData({
                            'post.votes': originalVotes,
                            'post.isVoted': originalIsVoted,
                            'post.likeIcon': likeIcon.getLikeIcon(originalVotes, originalIsVoted)
                        });
                    } else if (newVotes !== res.result.votes) {
                        this.setData({
                            'post.votes': res.result.votes,
                            'post.likeIcon': likeIcon.getLikeIcon(res.result.votes, newIsVoted)
                        });
                    }

                    // === Êñ∞Â¢ûÔºöÊõ¥Êñ∞È¶ñÈ°µÁºìÂ≠ò‰∏≠ÁöÑÂ∏ñÂ≠êÊï∞ÊçÆ ===
                    if (res.result.success) {
                        console.log('„ÄêÂ∏ñÂ≠êËØ¶ÊÉÖÁÇπËµû„ÄëÊõ¥Êñ∞È¶ñÈ°µÁºìÂ≠ò‰∏≠ÁöÑÂ∏ñÂ≠êÊï∞ÊçÆ');
                        dataCache.updatePostLikeInCache(postId, this.post.votes, this.post.isVoted, this.post.likeIcon);
                    }
                }).catch(() => {
                    this.setData({
                        'post.votes': originalVotes,
                        'post.isVoted': originalIsVoted,
                        'post.likeIcon': likeIcon.getLikeIcon(originalVotes, originalIsVoted)
                    });
                    uni.showToast({
                        title: 'Êìç‰ΩúÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªú',
                        icon: 'none'
                    });
                }).finally(() => {
                    this.setData({
                        votingInProgress: false
                    });
                });
        },

        onFavorite: function () {
            if (this.isFavorited) {
                uni.showToast({
                    title: 'Â∑≤ÁªèÊî∂ËóèËøá‰∫Ü',
                    icon: 'none'
                });
                return;
            }
            this.setData({
                showFavoriteModal: true
            });
        },

        hideFavoriteModal: function () {
            this.setData({
                showFavoriteModal: false
            });
        },

        onFavoriteSuccess: function () {
            this.hideFavoriteModal();
            this.setData({
                isFavorited: true,
                favoriteButtonText: 'Â∑≤Êî∂Ëóè',
                favoriteButtonClass: 'favorite-button favorited'
            });
            uni.showToast({
                title: 'Êî∂ËóèÊàêÂäü',
                icon: 'success'
            });
        },

        handlePreview: function (event) {
            const currentUrl = event.currentTarget.dataset.src;
            const originalUrls = event.currentTarget.dataset.originalImageUrls;
            if (currentUrl) {
                uni.previewImage({
                    current: currentUrl,
                    urls: originalUrls || [currentUrl]
                });
            } else {
                uni.showToast({
                    title: 'ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•',
                    icon: 'none'
                });
            }
        },

        onImageLoad: function (e) {
            const { postid, postindex = 0, imgindex = 0, type } = e.currentTarget.dataset;
            const { width: originalWidth, height: originalHeight } = e.detail;
            if (!originalWidth || !originalHeight) {
                return;
            }
            if (type === 'multi' && imgindex === 0) {
                const query = uni.createSelectorQuery().in(this);
                query
                    .select(`#swiper-${postid}`)
                    .boundingClientRect((rect) => {
                        if (rect && rect.width) {
                            const containerWidth = rect.width;
                            const actualRatio = originalWidth / originalHeight;
                            const maxRatio = 1.7777777777777777;
                            const minRatio = 0.5625;
                            let targetRatio = actualRatio;
                            if (actualRatio > maxRatio) targetRatio = maxRatio;
                            else if (actualRatio < minRatio) {
                                targetRatio = minRatio;
                            }
                            const displayHeight = containerWidth / targetRatio;
                            if (this.swiperHeights[postindex] !== displayHeight) {
                                this.setData({
                                    [`swiperHeights[${postindex}]`]: displayHeight
                                });
                            }
                        }
                    })
                    .exec();
            }
            if (type === 'single') {
                const actualRatio = originalWidth / originalHeight;
                const minRatio = 0.5625;
                if (actualRatio < minRatio) {
                    const query = uni.createSelectorQuery().in(this);
                    query
                        .select(`#single-image-${postid}`)
                        .boundingClientRect((rect) => {
                            if (rect && rect.width) {
                                const containerWidth = rect.width;
                                const displayHeight = containerWidth / minRatio;
                                if (this.imageClampHeights[postid] !== displayHeight) {
                                    this.setData({
                                        [`imageClampHeights.${postid}`]: displayHeight
                                    });
                                }
                            }
                        })
                        .exec();
                }
            }
        },

        onImageError: function (e) {
            console.error('ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•', e);
        },

        onAvatarError: function (e) {
            console.error('Â§¥ÂÉèÂä†ËΩΩÂ§±Ë¥•', e);
        },

        updateSubmitState: function () {
            const hasText = (this.newComment || '').trim().length > 0;
            const hasImages = Array.isArray(this.commentImages) && this.commentImages.length > 0;
            const disabled = (!hasText && !hasImages) || this.isSubmittingComment;
            if (this.isSubmitDisabled !== disabled) {
                this.setData({
                    isSubmitDisabled: disabled
                });
            }
        },

        onCommentInput: function (e) {
            this.setData(
                {
                    newComment: e.detail.value
                },
                () => {
                    this.updateSubmitState();
                }
            );
        },

        toggleEmojiPanel: function () {
            const shouldShow = !this.showEmojiPanel;
            const updateData = {
                showEmojiPanel: shouldShow,
                isFocus: !shouldShow
            };
            if (shouldShow) {
                updateData.keyboardHeight = 0;
                uni.hideKeyboard();
            }
            this.setData(updateData);
        },

        insertEmoji: function (e) {
            const emoji = e.currentTarget.dataset.emoji;
            if (!emoji) {
                return;
            }
            const newComment = (this.newComment || '') + emoji;
            this.setData(
                {
                    newComment: newComment
                },
                () => {
                    this.updateSubmitState();
                }
            );
        },

        closeEmojiPanel: function () {
            if (this.showEmojiPanel) {
                this.setData({
                    showEmojiPanel: false
                });
            }
        },

        chooseCommentImages: function () {
            this.closeEmojiPanel();
            const existing = this.commentImages ? this.commentImages.length : 0;
            const remaining = this.maxCommentImages - existing;
            if (remaining <= 0) {
                uni.showToast({
                    title: 'ÊúÄÂ§öÈÄâÊã©3Âº†ÂõæÁâá',
                    icon: 'none'
                });
                return;
            }

            // Á°Æ‰øùËæìÂÖ•Ê°Ü‰øùÊåÅÂ±ïÂºÄÁä∂ÊÄÅ
            if (!this.isInputExpanded) {
                this.expandInput();
            }
            uni.chooseImage({
                count: remaining,
                sizeType: ['original', 'compressed'],
                sourceType: ['album', 'camera'],
                success: (res) => {
                    const tempFiles =
                        res.tempFiles ||
                        (res.tempFilePaths || []).map((path) => ({
                            tempFilePath: path,
                            size: 0
                        }));
                    const tasks = tempFiles.map((file) => this.prepareCommentImage(file));
                    Promise.all(tasks)
                        .then((processedImages) => {
                            const validImages = processedImages.filter((item) => !!item);
                            if (validImages.length === 0) {
                                return;
                            }
                            const updatedImages = (this.commentImages || []).concat(validImages);
                            this.setData(
                                {
                                    commentImages: updatedImages.slice(0, this.maxCommentImages)
                                },
                                () => {
                                    this.updateSubmitState();
                                    // ÈÄâÊã©ÂõæÁâáÂêé‰øùÊåÅËæìÂÖ•Ê°ÜÂ±ïÂºÄÁä∂ÊÄÅ
                                    this.setData({
                                        isInputExpanded: true,
                                        isFocus: false // ‰∏çËá™Âä®ËÅöÁÑ¶ÔºåÈÅøÂÖçÈîÆÁõòÂºπÂá∫
                                    });
                                }
                            );
                        })
                        .catch((err) => {
                            console.error('ËØÑËÆ∫ÂõæÁâáÂ§ÑÁêÜÂ§±Ë¥•:', err);
                            uni.showToast({
                                title: 'ÂõæÁâáÂ§ÑÁêÜÂ§±Ë¥•',
                                icon: 'none'
                            });
                        });
                },
                fail: (err) => {
                    if (err && err.errMsg && err.errMsg.indexOf('cancel') === -1) {
                        console.error('ÈÄâÊã©ËØÑËÆ∫ÂõæÁâáÂ§±Ë¥•:', err);
                        uni.showToast({
                            title: 'Êó†Ê≥ïÈÄâÊã©ÂõæÁâá',
                            icon: 'none'
                        });
                    }
                }
            });
        },

        prepareCommentImage: function (file) {
            return new Promise((resolve) => {
                const tempPath = file.tempFilePath || file.path || (Array.isArray(file.tempFilePaths) ? file.tempFilePaths[0] : '');
                if (!tempPath) {
                    resolve(null);
                    return;
                }
                const sizeInBytes = file.size || 0;
                // Èôç‰ΩéÂéãÁº©ÈòàÂÄºÂà∞200KBÔºåÁ°Æ‰øùÊâÄÊúâË∂ÖËøá200KBÁöÑÂõæÁâáÈÉΩË¢´ÂéãÁº©
                const needCompression = sizeInBytes > 204800;
                const imageInfo = {
                    id: 'comment_' + Date.now() + '_' + Math.floor(Math.random() * 100000),
                    originalPath: tempPath,
                    previewUrl: tempPath,
                    compressedPath: tempPath,
                    size: sizeInBytes,
                    needCompression: needCompression
                };
                if (!needCompression) {
                    resolve(imageInfo);
                    return;
                }
                this.compressCommentImage(imageInfo)
                    .then((resolvedInfo) => {
                        resolve(resolvedInfo);
                    })
                    .catch((err) => {
                        console.warn('ËØÑËÆ∫ÂõæÁâáÂéãÁº©ÂºÇÂ∏∏:', err);
                        imageInfo.compressedPath = imageInfo.originalPath;
                        imageInfo.previewUrl = imageInfo.originalPath;
                        imageInfo.needCompression = false;
                        resolve(imageInfo);
                    });
            });
        },

        compressCommentImage: function (imageInfo) {
            return new Promise((resolve) => {
                // ‰ΩøÁî®Êõ¥ÊøÄËøõÁöÑÂéãÁº©ÂèÇÊï∞ÔºåÁ°Æ‰øùÊñá‰ª∂Â§ßÂ∞è‰∏çË∂ÖËøá200KB
                const compressWithQuality = (quality) => {
                    uni.compressImage({
                        src: imageInfo.originalPath,
                        quality: quality,
                        success: (res) => {
                            // Ê£ÄÊü•ÂéãÁº©ÂêéÁöÑÊñá‰ª∂Â§ßÂ∞è
                            uni.getFileInfo({
                                filePath: res.tempFilePath,
                                success: (fileInfo) => {
                                    const compressedSize = fileInfo.size;
                                    console.log(`ÂéãÁº©Ë¥®Èáè${quality}%ÔºåÊñá‰ª∂Â§ßÂ∞è: ${(compressedSize / 1024).toFixed(2)}KB`);

                                    // Â¶ÇÊûúÊñá‰ª∂Â§ßÂ∞èË∂ÖËøá200KB‰∏îË¥®ÈáèËøòÂèØ‰ª•ÁªßÁª≠Èôç‰ΩéÔºåÂàôÁªßÁª≠ÂéãÁº©
                                    if (compressedSize > 204800 && quality > 30) {
                                        console.log(`Êñá‰ª∂Â§ßÂ∞è${(compressedSize / 1024).toFixed(2)}KBË∂ÖËøá200KBÔºåÁªßÁª≠ÂéãÁº©...`);
                                        compressWithQuality(quality - 10);
                                    } else {
                                        imageInfo.compressedPath = res.tempFilePath;
                                        imageInfo.previewUrl = res.tempFilePath;
                                        imageInfo.compressedSize = compressedSize;
                                        console.log(`ÊúÄÁªàÂéãÁº©Ë¥®Èáè${quality}%ÔºåÊñá‰ª∂Â§ßÂ∞è: ${(compressedSize / 1024).toFixed(2)}KB`);
                                        resolve(imageInfo);
                                    }
                                },
                                fail: () => {
                                    // Â¶ÇÊûúÊó†Ê≥ïËé∑ÂèñÊñá‰ª∂‰ø°ÊÅØÔºåÁõ¥Êé•‰ΩøÁî®ÂéãÁº©ÁªìÊûú
                                    imageInfo.compressedPath = res.tempFilePath;
                                    imageInfo.previewUrl = res.tempFilePath;
                                    resolve(imageInfo);
                                }
                            });
                        },
                        fail: (err) => {
                            console.warn(`ÂéãÁº©Ë¥®Èáè${quality}%Â§±Ë¥•:`, err);
                            if (quality > 30) {
                                // Â¶ÇÊûúÂéãÁº©Â§±Ë¥•‰∏îË¥®ÈáèËøòÂèØ‰ª•Èôç‰ΩéÔºåÂ∞ùËØïÊõ¥‰ΩéÁöÑË¥®Èáè
                                compressWithQuality(quality - 10);
                            } else {
                                // Â¶ÇÊûúÊâÄÊúâÂéãÁº©ÈÉΩÂ§±Ë¥•Ôºå‰ΩøÁî®ÂéüÂõæ
                                imageInfo.compressedPath = imageInfo.originalPath;
                                imageInfo.previewUrl = imageInfo.originalPath;
                                imageInfo.needCompression = false;
                                resolve(imageInfo);
                            }
                        }
                    });
                };

                // ‰ªé60%Ë¥®ÈáèÂºÄÂßãÂéãÁº©ÔºåÈÄêÊ≠•Èôç‰ΩéÁõ¥Âà∞Êñá‰ª∂Â§ßÂ∞èÁ¨¶ÂêàË¶ÅÊ±Ç
                compressWithQuality(60);
            });
        },

        removeCommentImage: function (e) {
            const index = e.currentTarget.dataset.index;
            if (index === undefined) {
                return;
            }
            const images = (this.commentImages || []).slice();
            images.splice(index, 1);
            this.setData(
                {
                    commentImages: images
                },
                () => {
                    this.updateSubmitState();
                }
            );
        },

        previewSelectedCommentImage: function (e) {
            const index = e.currentTarget.dataset.index || 0;
            const images = this.commentImages || [];
            if (!images.length) {
                return;
            }
            const urls = images.map((item) => item.previewUrl);
            uni.previewImage({
                current: urls[index],
                urls: urls
            });
        },

        uploadCommentImages: function () {
            const images = this.commentImages || [];
            if (!images.length) {
                return Promise.resolve([]);
            }
            const openid = this.getCurrentUserId() || 'guest';
            const timestamp = Date.now();
            return Promise.all(
                images.map((image, index) => {
                    const uniqueKey = (openid || 'guest') + '_' + timestamp + '_' + index;
                    const compressedCloudPath = 'comment_images/' + uniqueKey + '_compressed.jpg';
                    return uniCloud
                        .uploadFile({
                            cloudPath: compressedCloudPath,
                            filePath: image.compressedPath || image.previewUrl || image.originalPath
                        })
                        .then((compressedRes) => {
                            if (image.needCompression) {
                                const originalCloudPath = 'comment_images/' + uniqueKey + '_original.jpg';
                                return uniCloud
                                    .uploadFile({
                                        cloudPath: originalCloudPath,
                                        filePath: image.originalPath
                                    })
                                    .then((originalRes) => ({
                                        compressedUrl: compressedRes.fileID,
                                        originalUrl: originalRes.fileID
                                    }));
                            }
                            return {
                                compressedUrl: compressedRes.fileID,
                                originalUrl: compressedRes.fileID
                            };
                        });
                })
            );
        },

        previewCommentImageFromList: function (e) {
            const commentIndex = Number(e.currentTarget.dataset.commentIndex);
            const replyIndexRaw = e.currentTarget.dataset.replyIndex;
            const replyIndex = typeof replyIndexRaw === 'undefined' ? -1 : Number(replyIndexRaw);
            const imageIndex = Number(e.currentTarget.dataset.imageIndex) || 0;
            const isReplyRaw = e.currentTarget.dataset.isReply;
            const isReply = isReplyRaw === true || isReplyRaw === 'true';
            let images = [];
            if (!Number.isNaN(commentIndex) && commentIndex >= 0) {
                const targetComment = this.comments[commentIndex];
                if (targetComment) {
                    if (isReply && Array.isArray(targetComment.replies) && replyIndex >= 0) {
                        const targetReply = targetComment.replies[replyIndex];
                        if (targetReply) {
                            if (Array.isArray(targetReply.originalImageUrls) && targetReply.originalImageUrls.length > 0) {
                                images = targetReply.originalImageUrls;
                            } else if (Array.isArray(targetReply.imageUrls)) {
                                images = targetReply.imageUrls;
                            }
                        }
                    } else {
                        if (Array.isArray(targetComment.originalImageUrls) && targetComment.originalImageUrls.length > 0) {
                            images = targetComment.originalImageUrls;
                        } else if (Array.isArray(targetComment.imageUrls)) {
                            images = targetComment.imageUrls;
                        }
                    }
                }
            }
            if (!images || !images.length) {
                return;
            }
            uni.previewImage({
                current: images[imageIndex] || images[0],
                urls: images
            });
        },

        onSubmitComment: async function () {
            if (this.isSubmitDisabled || this.isSubmittingComment) {
                return;
            }
            const trimmedContent = (this.newComment || '').trim();
            const hasContent = trimmedContent.length > 0;
            const hasImages = Array.isArray(this.commentImages) && this.commentImages.length > 0;
            if (!hasContent && !hasImages) {
                uni.showToast({
                    title: 'ËØ∑ËæìÂÖ•ÂÜÖÂÆπÊàñÊ∑ªÂä†ÂõæÁâá',
                    icon: 'none'
                });
                return;
            }
            const postId = this.post && this.post._id ? this.post._id : '';
            if (!postId) {
                uni.showToast({
                    title: 'Â∏ñÂ≠ê‰ø°ÊÅØÁº∫Â§±',
                    icon: 'none'
                });
                return;
            }
            const parentId = this.replyToComment;
            const replyToAuthor = this.replyToAuthor;
            this.setData({
                isSubmittingComment: true
            });
            this.updateSubmitState();
            uni.showLoading({
                title: 'Êèê‰∫§‰∏≠...'
            });
            try {
                const imageUploadResults = await this.uploadCommentImages();
                const imageUrls = imageUploadResults.map((item) => item.compressedUrl);
                const originalImageUrls = imageUploadResults.map((item) => item.originalUrl);
                const res = await this.callCloudFunction('addComment', {
                        postId: postId,
                        content: trimmedContent,
                        parentId: parentId,
                        replyToAuthorName: replyToAuthor,
                        imageUrls: imageUrls,
                        originalImageUrls: originalImageUrls
                    });
                uni.hideLoading();
                if (res.result && res.result.success) {
                    uni.showToast({
                        title: 'ËØÑËÆ∫ÊàêÂäü'
                    });
                    const newCommentCount = this.commentCount + 1;
                    this.setData({
                        newComment: '',
                        commentImages: [],
                        showEmojiPanel: false,
                        commentCount: newCommentCount
                    });
                    this.updateSubmitState();
                    this.collapseInput();
                    this.getComments(postId);
                    const pages = getCurrentPages();
                    if (pages.length > 1) {
                        const prePage = pages[pages.length - 2];
                        if ((prePage.route === 'pages/index/index' || prePage.route === 'pages/profile/profile') && typeof prePage.updatePostCommentCount === 'function') {
                            prePage.updatePostCommentCount(postId, newCommentCount);
                        }
                    }
                } else {
                    uni.showToast({
                        title: (res.result && res.result.message) || 'ËØÑËÆ∫Â§±Ë¥•',
                        icon: 'none'
                    });
                }
            } catch (error) {
                console.log('CatchClause', error);
                console.log('CatchClause', error);
                uni.hideLoading();
                console.error('Failed to add comment with media:', error);
                uni.showToast({
                    title: 'ËØÑËÆ∫Â§±Ë¥•',
                    icon: 'none'
                });
            } finally {
                this.setData({
                    isSubmittingComment: false
                });
                this.updateSubmitState();
            }
        },

        showReplyInput: function (e) {
            console.log('--- showReplyInput function triggered ---');
            console.log('Êî∂Âà∞ÁöÑ data- attributes:', e.currentTarget.dataset);
            const commentId = e.currentTarget.dataset.commentId;
            const authorName = e.currentTarget.dataset.authorName;
            this.setData({
                replyToComment: commentId,
                replyToAuthor: authorName
            });
            console.log('ËÆæÁΩÆÂêéÁöÑÂõûÂ§çÁä∂ÊÄÅ:', {
                replyToComment: this.replyToComment,
                replyToAuthor: this.replyToAuthor
            });
            this.expandInput();
        },

        cancelReply: function () {
            this.setData({
                replyToComment: null,
                replyToAuthor: ''
            });
            console.log('ÂõûÂ§çÁä∂ÊÄÅÂ∑≤Ë¢´ÂèñÊ∂à');
        },

        onDeleteComment: function (e) {
            const { commentId, parentId } = e.currentTarget.dataset;
            if (!commentId) {
                return;
            }
            uni.showModal({
                title: 'Âà†Èô§ËØÑËÆ∫',
                content: 'Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ËØÑËÆ∫ÂêóÔºü',
                confirmColor: '#ff4d4f',
                success: (res) => {
                    if (!res.confirm) {
                        return;
                    }
                    uni.showLoading({
                        title: 'Ê≠£Âú®Âà†Èô§',
                        mask: true
                    });
                    this.callCloudFunction('deleteComment', {
                            commentId
                        }).then((result) => {
                            if (result.result && result.result.success) {
                                const deletedCount = Math.max(1, result.result.deletedCount || 1);
                                let updatedComments;
                                if (parentId) {
                                    updatedComments = this.comments.map((comment) => ({
                                        ...comment,
                                        replies: comment.replies ? comment.replies.slice() : []
                                    }));
                                    const parentIndex = updatedComments.findIndex((comment) => comment._id === parentId);
                                    if (parentIndex !== -1) {
                                        updatedComments[parentIndex].replies = updatedComments[parentIndex].replies.filter((reply) => reply._id !== commentId);
                                    }
                                } else {
                                    updatedComments = this.comments.filter((comment) => comment._id !== commentId);
                                }
                                const newCommentCount = Math.max(0, this.commentCount - deletedCount);
                                this.setData({
                                    comments: updatedComments,
                                    commentCount: newCommentCount
                                });
                                const pages = getCurrentPages();
                                if (pages.length > 1) {
                                    const prePage = pages[pages.length - 2];
                                    if (typeof prePage.updatePostCommentCount === 'function') {
                                        prePage.updatePostCommentCount(this.post && this.post._id ? this.post._id : '', newCommentCount);
                                    }
                                }
                                uni.showToast({
                                    title: 'Â∑≤Âà†Èô§',
                                    icon: 'success'
                                });
                            } else {
                                uni.showToast({
                                    title: (result.result && result.result.message) || 'Âà†Èô§Â§±Ë¥•',
                                    icon: 'none'
                                });
                            }
                        }).catch((err) => {
                            console.error('Failed to delete comment', err);
                            uni.showToast({
                                title: 'Âà†Èô§Â§±Ë¥•',
                                icon: 'none'
                            });
                        }).finally(() => {
                            uni.hideLoading();
                        });
                }
            });
        },

        toggleLikeComment: function (e) {
            const { commentId } = e.currentTarget.dataset;
            const postId = this.post && this.post._id ? this.post._id : '';
            const comments = this.comments;
            const { comment, isReply } = this.findComment(comments, commentId);
            if (!comment) {
                return;
            }
            const newLikeState = !comment.liked;
            const oldLikes = comment.likes || 0;
            comment.liked = newLikeState;
            comment.likes = oldLikes + (newLikeState ? 1 : -1);
            comment.likeIcon = likeIcon.getLikeIcon(comment.likes, comment.liked);
            this.setData({
                comments: comments
            });
            this.callCloudFunction('likeComment', {
                    commentId: commentId,
                    postId: postId
                }).then((res) => {
                    if (res.result && res.result.success) {
                        if (comment.likes !== res.result.likes) {
                            this.updateCommentLikeStatus(commentId, newLikeState, res.result.likes);
                        }
                    } else {
                        this.updateCommentLikeStatus(commentId, !newLikeState, oldLikes);
                        uni.showToast({
                            title: 'Êìç‰ΩúÂ§±Ë¥•',
                            icon: 'none'
                        });
                    }
                }).catch((err) => {
                    this.updateCommentLikeStatus(commentId, !newLikeState, oldLikes);
                    console.error('Failed to like comment', err);
                    uni.showToast({
                        title: 'ÁΩëÁªúÈîôËØØ',
                        icon: 'none'
                    });
                });
        },

        updateCommentLikeStatus: function (commentId, newLikeState, finalLikes) {
            let comments = this.comments;
            const { comment, isReply } = this.findComment(comments, commentId);
            if (comment) {
                comment.liked = newLikeState;
                comment.likes = finalLikes;
                comment.likeIcon = likeIcon.getLikeIcon(comment.likes, comment.liked);
                this.setData({
                    comments: comments
                });
            }
        },

        findComment: function (comments, commentId) {
            for (let i = 0; i < comments.length; i++) {
                if (comments[i]._id === commentId) {
                    return {
                        comment: comments[i],
                        isReply: false
                    };
                }
                if (comments[i].replies) {
                    for (let j = 0; j < comments[i].replies.length; j++) {
                        if (comments[i].replies[j]._id === commentId) {
                            return {
                                comment: comments[i].replies[j],
                                isReply: true
                            };
                        }
                    }
                }
            }
            return {
                comment: null,
                isReply: false
            };
        },

        toggleShowAllReplies: function (e) {
            const commentId = e.currentTarget.dataset.commentId;
            let comments = this.comments;
            const comment = comments.find((c) => c._id === commentId);
            if (comment) {
                comment.showAllReplies = !comment.showAllReplies;
                this.setData({
                    comments: comments
                });
            }
        },

        formatTime: function (dateString) {
            if (!dateString) {
                return '';
            }
            const date = new Date(dateString);
            const now = new Date();
            const diff = now.getTime() - date.getTime();
            const minutes = Math.floor(diff / 60000);
            if (minutes < 1) {
                return 'ÂàöÂàö';
            }
            if (minutes < 60) {
                return `${minutes}ÂàÜÈíüÂâç`;
            }
            const hours = Math.floor(diff / 3600000);
            if (hours < 24) {
                return `${hours}Â∞èÊó∂Ââç`;
            }
            const days = Math.floor(diff / 86400000);
            if (days < 7) {
                return `${days}Â§©Ââç`;
            }
            return date.toLocaleDateString();
        },

        prepareFollowState: function (authorOpenid) {
            const currentUserId = this.getCurrentUserId();
            console.log('„ÄêÂÖ≥Ê≥®Áä∂ÊÄÅ„ÄëprepareFollowStateË∞ÉÁî®:', {
                authorOpenid,
                currentUserId,
                isSameUser: authorOpenid === currentUserId
            });
            if (!authorOpenid || !currentUserId || authorOpenid === currentUserId) {
                console.log('„ÄêÂÖ≥Ê≥®Áä∂ÊÄÅ„Äë‰∏çÊòæÁ§∫ÂÖ≥Ê≥®ÊåâÈíÆ - Ëá™Â∑±ÊàñÊó†ÊïàÁî®Êà∑');
                this.setData({
                    showFollowButton: false,
                    isFollowing: false,
                    isFollowedByAuthor: false,
                    isMutualFollow: false
                });
                return;
            }
            console.log('„ÄêÂÖ≥Ê≥®Áä∂ÊÄÅ„ÄëÊòæÁ§∫ÂÖ≥Ê≥®ÊåâÈíÆ');
            this.setData({
                showFollowButton: true,
                isFollowing: false,
                isFollowedByAuthor: false,
                isMutualFollow: false
            });
            this.fetchFollowStatusWithCache(authorOpenid);
        },

        fetchFollowStatusWithCache: function (targetOpenid) {
            if (!targetOpenid) {
                return;
            }
            const currentUserId = this.getCurrentUserId();
            if (!currentUserId) {
                return;
            }

            // ‰ΩøÁî®ÁºìÂ≠òËé∑ÂèñÂÖ≥Ê≥®Áä∂ÊÄÅ
            followCache.getFollowStatus(currentUserId, targetOpenid).then((followData) => {
                if (followData) {
                    this.setData({
                        isFollowing: followData.isFollowing,
                        isFollowedByAuthor: followData.isFollowedByAuthor,
                        isMutualFollow: followData.isMutualFollow
                    });
                }
            });
        },

        fetchFollowStatus: function (targetOpenid) {
            if (!targetOpenid) {
                return;
            }
            this.callCloudFunction('follow', {
                    action: 'checkFollow',
                    targetOpenid
                }).then((res) => {
                    if (res.result && res.result.success) {
                        this.setData({
                            isFollowing: !!res.result.isFollowing,
                            isFollowedByAuthor: !!res.result.isFollower,
                            isMutualFollow: !!res.result.isMutual
                        });
                    } else {
                        console.warn('Ê£ÄÊü•ÂÖ≥Ê≥®Áä∂ÊÄÅÂ§±Ë¥•', res.result);
                    }
                }).catch((err) => {
                    console.error('Ê£ÄÊü•ÂÖ≥Ê≥®Áä∂ÊÄÅË∞ÉÁî®Â§±Ë¥•:', err);
                });
        },

        onFollowTap: function () {
            if (this.followPending || !this.post) {
                return;
            }
            const targetOpenid = this.post._openid;
            if (!targetOpenid) {
                return;
            }
            const currentUserId = this.getCurrentUserId();
            if (!currentUserId) {
                uni.showToast({
                    title: 'ËØ∑ÂÖàÁôªÂΩï',
                    icon: 'none'
                });
                return;
            }
            this.setData({
                followPending: true
            });

            // ‰ΩøÁî®ÁºìÂ≠òÂàáÊç¢ÂÖ≥Ê≥®Áä∂ÊÄÅ
            followCache
                .toggleFollowStatus(currentUserId, targetOpenid)
                .then((followData) => {
                    if (followData) {
                        this.setData({
                            isFollowing: followData.isFollowing,
                            isFollowedByAuthor: followData.isFollowedByAuthor,
                            isMutualFollow: followData.isMutualFollow
                        });
                        uni.showToast({
                            title: followData.isFollowing ? 'ÂÖ≥Ê≥®ÊàêÂäü' : 'Â∑≤ÂèñÊ∂àÂÖ≥Ê≥®',
                            icon: 'success'
                        });
                    } else {
                        uni.showToast({
                            title: 'Êìç‰ΩúÂ§±Ë¥•',
                            icon: 'none'
                        });
                    }
                })
                .catch((err) => {
                    console.error('ÂàáÊç¢ÂÖ≥Ê≥®Áä∂ÊÄÅÂ§±Ë¥•:', err);
                    uni.showToast({
                        title: 'ÁΩëÁªúÈîôËØØ',
                        icon: 'none'
                    });
                })
                .finally(() => {
                    this.setData({
                        followPending: false
                    });
                });
        },

        getCurrentUserId: function () {
            return this.openid || uni.getStorageSync('openid') || uni.getStorageSync('userOpenId');
        },

        retryLoad: function () {
            if (this.currentPostId) {
                this.setData({
                    isLoading: true,
                    post: null
                });
                this.loadPostDetail(this.currentPostId);
            }
        },

        navigateToUserProfile: function (e) {
            const userId = e.currentTarget.dataset.userId;
            if (userId) {
                const currentUserOpenid = this.openid;
                if (userId === currentUserOpenid) {
                    console.log('„ÄêÂ∏ñÂ≠êËØ¶ÊÉÖ„ÄëÁÇπÂáªÁöÑÊòØËá™Â∑±Â§¥ÂÉèÔºåÂàáÊç¢Âà∞ÊàëÁöÑÈ°µÈù¢');
                    uni.switchTab({
                        url: '/pages/profile/profile'
                    });
                } else {
                    console.log('„ÄêÂ∏ñÂ≠êËØ¶ÊÉÖ„ÄëÁÇπÂáªÁöÑÊòØ‰ªñ‰∫∫Â§¥ÂÉèÔºåË∑≥ËΩ¨Âà∞Áî®Êà∑‰∏ªÈ°µ');
                    uni.navigateTo({
                        url: `/pages/user-profile/user-profile?userId=${userId}`
                    });
                }
            }
        },

        preventBubble: function () {
            // Á©∫ÂáΩÊï∞Ôºå‰ªÖÁî®‰∫éÈòªÊ≠¢‰∫ã‰ª∂ÂÜíÊ≥°
        },

        expandInput: function () {
            this.setData({
                isInputExpanded: true,
                isFocus: true,
                showEmojiPanel: false
            });
        },

        onInputFocus: function (e) {
            console.log('ÈîÆÁõòÂºπËµ∑ÔºåÈ´òÂ∫¶‰∏∫:', e.detail.height);
            this.setData({
                keyboardHeight: e.detail.height,
                showEmojiPanel: false
            });
        },

        onInputBlur: function () {
            setTimeout(() => {
                this.setData({
                    isFocus: false,
                    keyboardHeight: 0
                });
            }, 100);
        },

        collapseInput: function () {
            this.setData({
                isInputExpanded: false,
                isFocus: false,
                keyboardHeight: 0,
                replyToComment: null,
                replyToAuthor: '',
                showEmojiPanel: false
            });
        },

        recordViewBehavior: function () {
            if (!this.currentPostId || !this.viewStartTime) {
                return;
            }
            const viewDuration = Math.floor((Date.now() - this.viewStartTime) / 1000);
            if (viewDuration < 3) {
                return;
            }
            this.callCloudFunction('recordView', {
                    postId: this.currentPostId,
                    viewDuration: viewDuration
                }).then((res) => {
                    console.log('ÊµèËßàËÆ∞ÂΩïÂ∑≤‰øùÂ≠ò', res);
                }).catch((err) => {
                    console.error('ÊµèËßàËÆ∞ÂΩï‰øùÂ≠òÂ§±Ë¥•:', err);
                });
        },

        onTagClick: function (e) {
            const tag = e.currentTarget.dataset.tag;
            console.log('ÁÇπÂáªÊ†áÁ≠æ:', tag);
            uni.navigateTo({
                url: `/pages/tag-filter/tag-filter?tag=${encodeURIComponent(tag)}`,
                success: () => {
                    console.log('Ë∑≥ËΩ¨Âà∞Ê†áÁ≠æÁ≠õÈÄâÈ°µÈù¢ÊàêÂäü');
                },
                fail: (err) => {
                    console.error('Ë∑≥ËΩ¨Âà∞Ê†áÁ≠æÁ≠õÈÄâÈ°µÈù¢Â§±Ë¥•', err);
                    uni.showToast({
                        title: 'Ë∑≥ËΩ¨Â§±Ë¥•',
                        icon: 'none'
                    });
                }
            });
        }
    }
};
</script>
<style>
/* pages/post-detail/post-detail.wxss */
.container {
    padding: 20rpx;
    background-color: #f7f8fa;
    min-height: 100vh;
    padding-bottom: 140rpx;
}

.loading-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 400rpx;
    background-color: #fff;
    border-radius: 16rpx;
    margin: 30rpx;
    box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.05);
}

.loading-text {
    font-size: 28rpx;
    color: #999;
}

.error-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 100rpx 40rpx;
    text-align: center;
}

.error-icon {
    font-size: 120rpx;
    margin-bottom: 30rpx;
    opacity: 0.6;
}

.error-text {
    font-size: 32rpx;
    color: #666;
}

.post-detail-card {
    position: relative;
    background-color: #fff;
    border-radius: 16rpx;
    padding: 30rpx;
    margin-bottom: 20rpx;
    box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.05);
}

.post-detail-card.original-post {
    border: 3rpx solid #ebc88d;
    box-shadow: 0 6rpx 24rpx rgba(235, 200, 141, 0.4), 0 4rpx 12rpx rgba(0, 0, 0, 0.05);
    position: relative;
}

.post-detail-card.original-post::before {
    content: '';
    position: absolute;
    top: -2rpx;
    left: -2rpx;
    right: -2rpx;
    bottom: -2rpx;
    background: linear-gradient(45deg, #ebc88d, #f4d03f, #ebc88d);
    border-radius: 18rpx;
    z-index: -1;
    opacity: 0.6;
    filter: blur(10rpx);
}

.author-info {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    margin-bottom: 20rpx;
    gap: 20rpx;
}

.author-basic {
    display: flex;
    align-items: center;
    flex: 1;
    min-width: 0;
    gap: 12rpx;
    flex-wrap: wrap;
}

.follow-btn {
    padding: 0 28rpx;
    height: 60rpx;
    line-height: 60rpx;
    background-color: #9ed7ee;
    color: #ffffff;
    border: none;
    border-radius: 999rpx;
    font-size: 26rpx;
    flex-shrink: 0;
    margin-left: auto;
}

.follow-btn.following {
    background-color: #f0f0f0;
    color: #666666;
}

.follow-btn::after {
    border: none;
}

.follow-btn[disabled] {
    opacity: 0.7;
}

.author-avatar {
    width: 60rpx;
    height: 60rpx;
    border-radius: 50%;
    margin-right: 15rpx;
    background-color: #f5f5f5;
}

.author-name {
    font-weight: bold;
    font-size: 28rpx;
    color: #333;
}

.post-title {
    font-size: 36rpx;
    font-weight: bold;
    margin-bottom: 15rpx;
    line-height: 1.4;
    color: #333;
    word-break: break-word;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
}

.poem-author {
    font-size: 28rpx;
    color: #333;
    text-align: left;
    margin: 10rpx 0 15rpx 0;
    font-weight: bold;
    letter-spacing: 2rpx;
}

.post-content {
    font-size: 28rpx;
    line-height: 1.6;
    margin-bottom: 20rpx;
    white-space: pre-wrap;
    color: #666;
    word-break: break-word;
}

.image-container {
    position: relative;
    width: 100%;
    margin: 20rpx 0;
    background-color: #f5f5f5;
}

.post-image {
    width: 100%;
    height: auto;
    display: block;
    background-color: #f5f5f5;
    transition: transform 0.3s ease;
}

.post-image:active {
    transform: scale(1.05);
}

.post-image.single-image {
    width: 100% !important;
    height: auto !important;
    display: block !important;
    background-color: #f5f5f5;
}

.image-count-indicator {
    position: absolute;
    top: 20rpx;
    right: 20rpx;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    padding: 8rpx 16rpx;
    border-radius: 20rpx;
    font-size: 24rpx;
    z-index: 10;
    backdrop-filter: blur(10rpx);
}

.post-meta {
    margin-bottom: 15rpx;
}

.post-time {
    font-size: 24rpx;
    color: #999;
    opacity: 0.8;
}

.vote-section {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    padding-top: 20rpx;
    margin-top: 20rpx;
    border-top: 1rpx solid #f0f0f0;
}

.actions-left {
    display: flex;
    align-items: center;
}

.vote-count,
.comment-count {
    display: flex;
    align-items: center;
    font-size: 28rpx;
    color: #999;
    margin-left: 20rpx;
    transition: color 0.2s ease;
}

.vote-count {
    margin-left: 0rpx;
}

.action-emoji {
    font-size: 28rpx;
    margin-right: 8rpx;
}

.action-text {
    font-size: 28rpx;
    color: inherit;
}

.like-icon-container {
    margin-left: 20rpx;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 8rpx;
    border-radius: 8rpx;
    transition: all 0.2s ease;
}

.like-icon-container:active {
    transform: scale(0.95);
}

.vote-count.voted {
    color: #ff4757;
}

.button-group {
    display: flex;
    align-items: center;
}

.favorite-button {
    background-color: #ffc300;
    color: white;
    border: none;
    border-radius: 8rpx;
    font-size: 24rpx;
    padding: 8rpx 16rpx;
    line-height: 1.2;
    transition: all 0.2s ease;
}

.favorite-button:active {
    background-color: #e6b000;
}

.favorite-button::after {
    border: none;
}

.favorite-button.favorited {
    background-color: #999;
    color: #fff;
}

.favorite-button.favorited:active {
    background-color: #777;
}

.like-icon {
    width: 48rpx;
    height: 48rpx;
}

.comment-section {
    background-color: #fff;
    border-radius: 16rpx;
    padding: 30rpx;
    box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.05);
}

.section-title {
    font-size: 32rpx;
    font-weight: bold;
    margin-bottom: 20rpx;
    padding-bottom: 15rpx;
    border-bottom: 1rpx solid #f0f0f0;
    color: #333;
}

.comment-list {
    margin-top: 20rpx;
}

.comment-item {
    display: flex;
    margin-bottom: 30rpx;
    padding-bottom: 20rpx;
    border-bottom: 1rpx solid #f5f5f5;
}

.comment-item:last-child {
    border-bottom: none;
    margin-bottom: 0;
}

.comment-avatar {
    width: 60rpx;
    height: 60rpx;
    border-radius: 50%;
    margin-right: 15rpx;
    flex-shrink: 0;
    background-color: #f5f5f5;
}

.comment-main {
    display: flex;
    flex-direction: column;
    flex: 1;
    min-width: 0;
}

.comment-author {
    font-size: 28rpx;
    color: #333;
    font-weight: bold;
    margin-bottom: 8rpx;
}

.comment-content {
    font-size: 28rpx;
    color: #666;
    line-height: 1.5;
    word-break: break-word;
    margin-bottom: 10rpx;
}
.comment-image-grid {
    display: flex;
    flex-direction: column;
    gap: 12rpx;
    margin-bottom: 12rpx;
}

.comment-image {
    width: 100%;
    height: 400rpx;
    border-radius: 12rpx;
    background-color: #f2f2f2;
    display: block;
    object-fit: cover;
}

.reply-image-grid {
    margin-top: 10rpx;
}

.comment-footer {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    width: 100%;
}

.comment-time {
    font-size: 24rpx;
    color: #999;
    opacity: 0.8;
}

.comment-actions {
    display: flex;
    align-items: center;
}

.like-section {
    display: flex;
    align-items: center;
    padding: 8rpx 12rpx;
    margin-right: 15rpx;
    transition: all 0.2s ease;
}

.like-section:active {
    transform: scale(0.95);
}

.like-section .like-icon {
    width: 32rpx;
    height: 32rpx;
    margin-right: 8rpx;
}

.like-count {
    font-size: 26rpx;
    color: #666;
}

.delete-btn {
    display: flex;
    align-items: center;
    padding: 8rpx 12rpx;
    margin-right: 15rpx;
    transition: opacity 0.2s ease;
}

.delete-btn:active {
    opacity: 0.7;
}

.delete-text {
    font-size: 26rpx;
    color: #ff4d4f;
}

.reply-btn {
    display: flex;
    align-items: center;
    padding: 8rpx 12rpx;
    transition: opacity 0.2s ease;
}

.reply-btn:active {
    opacity: 0.7;
}

.reply-text {
    font-size: 26rpx;
    color: #9ed7ee;
}

.replies-container {
    margin-top: 15rpx;
    padding-left: 20rpx;
    border-left: 2rpx solid #f0f0f0;
}

.reply-item {
    display: flex;
    margin-bottom: 15rpx;
}

.reply-avatar {
    width: 40rpx;
    height: 40rpx;
    border-radius: 50%;
    margin-right: 10rpx;
    flex-shrink: 0;
    background-color: #f5f5f5;
}

.reply-main {
    display: flex;
    flex-direction: column;
    flex: 1;
    min-width: 0;
}

.reply-author {
    font-size: 24rpx;
    color: #333;
    font-weight: bold;
    margin-bottom: 4rpx;
}

.reply-content {
    font-size: 26rpx;
    color: #666;
    line-height: 1.4;
    word-break: break-word;
}

.reply-to {
    color: #9ed7ee;
    font-weight: bold;
}

.reply-footer {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    margin-top: 8rpx;
}

.reply-time {
    font-size: 22rpx;
    color: #999;
    opacity: 0.8;
}

.reply-actions {
    display: flex;
    align-items: center;
}

.show-more-replies {
    padding: 10rpx 0;
    transition: opacity 0.2s ease;
}

.show-more-replies:active {
    opacity: 0.7;
}

.show-more-text {
    font-size: 24rpx;
    color: #9ed7ee;
}

.no-comment-tip {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 60rpx 40rpx;
    text-align: center;
}

.empty-icon {
    font-size: 80rpx;
    margin-bottom: 20rpx;
    opacity: 0.6;
}

.empty-text {
    font-size: 28rpx;
    color: #999;
}

.input-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.4);
    z-index: 99;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}
.input-overlay.show {
    opacity: 1;
    pointer-events: auto;
}

.comment-input-area {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ffffff;
    z-index: 100;
    transition: bottom 0.2s ease-out;
    padding-bottom: constant(safe-area-inset-bottom);
    padding-bottom: env(safe-area-inset-bottom);
}

.collapsed-bar {
    padding: 16rpx 30rpx;
    display: flex;
    align-items: center;
    border-top: 1rpx solid #f0f0f0;
}
.collapsed-input-placeholder {
    flex: 1;
    height: 68rpx;
    line-height: 68rpx;
    padding: 0 24rpx;
    background-color: #f7f8fa;
    border-radius: 34rpx;
    font-size: 28rpx;
    color: #999;
}

.expanded-container {
    padding: 20rpx 30rpx;
    display: flex;
    flex-direction: column;
    border-top: 1rpx solid #f0f0f0;
}

.expanded-textarea {
    width: 100%;
    min-height: 180rpx;
    max-height: 350rpx;
    padding: 20rpx 24rpx;
    background-color: #ffffff;
    border-radius: 0;
    font-size: 30rpx;
    line-height: 1.6;
    box-sizing: border-box;
    border: none;
    -webkit-appearance: none;
    -webkit-box-sizing: border-box;
    -webkit-user-select: text;
    -webkit-touch-callout: default;
    outline: none;
}

.expanded-actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 20rpx;
    width: 100%;
}
.action-icons {
    display: flex;
    gap: 24rpx;
}

.action-icon {
    width: 64rpx;
    height: 64rpx;
    border-radius: 50%;
    background: #f3f5f7;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s ease;
}

.action-icon:active {
    transform: scale(0.92);
    background: #e6eef3;
}

.action-icon-text {
    font-size: 36rpx;
}

.selected-comment-images {
    display: flex;
    flex-wrap: wrap;
    gap: 12rpx;
    margin-top: 16rpx;
}

.selected-image-item {
    position: relative;
    width: 150rpx;
    height: 150rpx;
    border-radius: 12rpx;
    overflow: hidden;
}

.selected-image-thumb {
    width: 100%;
    height: 100%;
    background-color: #f2f2f2;
    display: block;
}

.remove-image-btn {
    position: absolute;
    top: 6rpx;
    right: 6rpx;
    width: 36rpx;
    height: 36rpx;
    border-radius: 50%;
    background: rgba(0, 0, 0, 0.55);
    color: #fff;
    font-size: 24rpx;
    display: flex;
    align-items: center;
    justify-content: center;
}

.emoji-panel {
    margin-top: 16rpx;
    padding: 20rpx 18rpx;
    background: #f6f7f9;
    border-radius: 16rpx;
    display: flex;
    flex-wrap: wrap;
    gap: 18rpx;
}

.emoji-item {
    font-size: 36rpx;
    padding: 6rpx 10rpx;
}

.reply-prompt {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    margin-bottom: 15rpx;
    padding: 0 10rpx;
}
.reply-prompt-text {
    font-size: 26rpx;
    color: #666;
}
.cancel-reply .cancel-text {
    font-size: 26rpx;
    color: #9ed7ee;
}

.submit-button {
    width: 120rpx !important;
    height: 64rpx !important;
    line-height: 64rpx !important;
    background-color: #9ed7ee;
    color: white;
    border-radius: 32rpx;
    font-size: 28rpx;
    padding: 0 !important;
    margin: 0 !important;
    border: none !important;
    box-sizing: border-box !important;
    flex-shrink: 0;
    transition: background-color 0.2s ease;
}
.submit-button[disabled] {
    background-color: #b3e6c9;
    color: #ffffff;
}
.submit-button::after {
    border: none;
}

.swiper-wrapper {
    position: relative;
    width: 100%;
}

.image-swiper {
    width: 100%;
    background-color: #f0f0f0;
    border-radius: 12rpx;
    overflow: hidden;
}

.swiper-item {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.post-image {
    max-width: 100%;
    max-height: 100%;
}

.image-count-indicator {
    position: absolute;
    bottom: 20rpx;
    right: 20rpx;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    padding: 8rpx 16rpx;
    border-radius: 20rpx;
    font-size: 24rpx;
    z-index: 10;
    backdrop-filter: blur(10rpx);
}

.post-tags {
    margin: 30rpx 0 10rpx 0;
    line-height: 1.5;
}

.post-tag {
    color: #24375f;
    font-size: 26rpx;
    margin-right: 10rpx;
    transition: all 0.2s ease;
    cursor: pointer;
}

.post-tag:active {
    color: #1a2a4a;
    opacity: 0.8;
}

.mutual-tag {
    font-size: 24rpx;
    padding: 4rpx 16rpx;
    border-radius: 999rpx;
    background-color: #e6f4ff;
    color: #1f6fd2;
    flex-shrink: 0;
}

.followed-tag {
    font-size: 24rpx;
    padding: 4rpx 16rpx;
    border-radius: 999rpx;
    background-color: #f4ebff;
    color: #7c55c7;
    flex-shrink: 0;
}
</style>

